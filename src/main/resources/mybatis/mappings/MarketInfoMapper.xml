<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.liuhu.socket.dao.MarketInfoMapper">
    <resultMap id="BaseResultMap" type="com.liuhu.socket.entity.MarketInfo">
        <result column="id" property="id" jdbcType="INTEGER"/>
        <result column="share_code" property="shareCode" jdbcType="VARCHAR"/>
        <result column="open_value" property="openValue" jdbcType="DOUBLE"/>
        <result column="end_value" property="endValue" jdbcType="DOUBLE"/>
        <result column="rise_fall" property="riseFall" jdbcType="DOUBLE"/>
        <result column="rise_fall_ratio" property="riseFallRatio" jdbcType="VARCHAR"/>
        <result column="highest" property="highest" jdbcType="DOUBLE"/>
        <result column="lowest" property="lowest" jdbcType="DOUBLE"/>
        <result column="pre_end_value" property="preEndValue" jdbcType="DOUBLE"/>
        <result column="total_amount" property="totalAmount" jdbcType="DOUBLE"/>
        <result column="date" property="date" jdbcType="TIMESTAMP"/>
    </resultMap>
    <insert id="insert" parameterType="com.liuhu.socket.entity.MarketInfo">
    insert into market_info (id, open_value, end_value, 
      rise_fall, rise_fall_ratio, highest, 
      lowest, date,pre_end_value,total_amount)
    values (#{id,jdbcType=INTEGER}, #{openValue,jdbcType=DOUBLE}, #{endValue,jdbcType=DOUBLE}, 
      #{riseFall,jdbcType=DOUBLE}, #{riseFallRatio,jdbcType=VARCHAR}, #{highest,jdbcType=DOUBLE}, 
      #{lowest,jdbcType=DOUBLE}, #{date,jdbcType=TIMESTAMP},#{preEndValue,jdbcType=DOUBLE},#{totalAmount,jdbcType=DOUBLE})
  </insert>
    <insert id="insertSelective" parameterType="com.liuhu.socket.entity.MarketInfo">
        insert into market_info
        <trim prefix="(" suffix=")" suffixOverrides=",">
            <if test="id != null">
                id,
            </if>
            <if test="openValue != null">
                open_value,
            </if>
            <if test="endValue != null">
                end_value,
            </if>
            <if test="riseFall != null">
                rise_fall,
            </if>
            <if test="riseFallRatio != null">
                rise_fall_ratio,
            </if>
            <if test="highest != null">
                highest,
            </if>
            <if test="lowest != null">
                lowest,
            </if>
            <if test="date != null">
                date,
            </if>
            <if test="totalAmount != null">
                total_amount,
            </if>
            <if test="preEndValue != null">
                pre_end_value,
            </if>
        </trim>
        <trim prefix="values (" suffix=")" suffixOverrides=",">
            <if test="id != null">
                #{id,jdbcType=INTEGER},
            </if>
            <if test="openValue != null">
                #{openValue,jdbcType=DOUBLE},
            </if>
            <if test="endValue != null">
                #{endValue,jdbcType=DOUBLE},
            </if>
            <if test="riseFall != null">
                #{riseFall,jdbcType=DOUBLE},
            </if>
            <if test="riseFallRatio != null">
                #{riseFallRatio,jdbcType=VARCHAR},
            </if>
            <if test="highest != null">
                #{highest,jdbcType=DOUBLE},
            </if>
            <if test="lowest != null">
                #{lowest,jdbcType=DOUBLE},
            </if>
            <if test="date != null">
                #{date,jdbcType=TIMESTAMP},
            </if>
            <if test="totalAmount != null">
                #{totalAmount,jdbcType=DOUBLE},
            </if>
            <if test="preEndValue != null">
                #{preEndValue,jdbcType=DOUBLE},
            </if>
        </trim>
    </insert>
    <select id="getShareInfo"
            parameterType="com.liuhu.socket.domain.input.MarketInputDomain"
            resultMap="BaseResultMap">
        select id,share_code, open_value, end_value,
        rise_fall, rise_fall_ratio, highest,
        lowest, date,total_amount,pre_end_value from market_info t
        where 1=1
        <if test="startTime != null">
            and t.date >= #{startTime}
        </if>
        <if test="endTime != null">
            and t.date <![CDATA[ <= ]]>
            #{endTime}
        </if>
        <if test="shareCode != null">
            and t.share_code = #{shareCode,jdbcType=VARCHAR}
        </if>
        order by t.date
    </select>
    <select id="getLastEndList"
            parameterType="com.liuhu.socket.domain.input.MarketInputDomain"
            resultType="com.liuhu.socket.entity.MarketInfo">
        select a.share_code as shareCode,
        a.end_value as endValue,
        a.total_amount as totalAmount,
        a.rise_fall_ratio as riseFallRatio,
        a.pre_end_value as preEndValue,
        a.date,
        c.share_name as shareName from
        (SELECT
        t.*
        FROM
        market_info t,
        (
        SELECT
        MAX(date) AS date,
        share_code
        FROM
        market_info t
        <where>
        <if test="endTime != null">
            and t.date <![CDATA[ <= ]]> #{endTime}
        </if>
        <if test="shareCode != null and shareCode !=''">
            and t.share_code = #{shareCode,jdbcType=VARCHAR}
        </if>
        </where>
        GROUP BY
        t.share_code
        ) t2
        WHERE
            t.share_code = t2.share_code
        AND t.date = t2.date
        UNION
        SELECT
        t3.*
        FROM
        market_info t3,
        (
        SELECT
        min(t2.date) AS date,
        t2.share_code
        FROM
        market_info t2
        <where>
            <if test="startTime != null">
                and t2.date >=#{startTime}
            </if>
            <if test="shareCode != null and shareCode !=''">
                and t2.share_code = #{shareCode,jdbcType=VARCHAR}
            </if>
        </where>
        GROUP BY
        t2.share_code
        ) t4
        WHERE
        t3.date = t4.date
        AND t3.share_code = t4.share_code) a
        LEFT JOIN share_info c ON c.share_code = a.share_code
    </select>
    <insert id="insertOrUpdateMarketInfo" useGeneratedKeys="true" parameterType="java.util.List">
        replace into market_info
        (open_value, end_value,
        rise_fall, rise_fall_ratio, highest,
        lowest, date,share_code,total_amount,pre_end_value)
        VALUES
        <foreach collection="list" item="it" separator=",">
            (#{it.openValue},#{it.endValue},#{it.riseFall},
            #{it.riseFallRatio},#{it.highest},#{it.lowest},
            #{it.date},#{it.shareCode},#{it.totalAmount},#{it.preEndValue})
        </foreach>
    </insert>
    <select id="queryMaxDate"
            resultType="java.util.Date">
        select max(date) as date  from market_info t where t.share_code =#{shareCode,jdbcType=VARCHAR}
    </select>

    <select id="queryRecentSerialRed" parameterType="com.liuhu.socket.dto.QueryRecentSerialRedConditionDO" resultType="com.liuhu.socket.domain.output.QueryRecentSerialRedOutPutDTO">
        SELECT DISTINCT
        first_value(share_code) over(PARTITION by share_code ) as shareCode,
        ROUND( (first_value(maxHighest)over(PARTITION BY share_code) - first_value(lastEndValue)over(PARTITION BY share_code) ) / first_value(lastEndValue)over(PARTITION BY share_code) * 100, 2 ) AS maxRatio,
        min(date) over(PARTITION by share_code ) AS startTime,
        first_value ( sumRatio ) over ( PARTITION BY share_code ORDER BY date desc) AS finalRatio,

        ROUND((first_value(minLowest)over(PARTITION BY share_code) - first_value(lastEndValue)over(PARTITION BY share_code) ) / first_value(lastEndValue)over(PARTITION BY share_code) * 100, 2 ) AS minRatio
        from
        (SELECT DISTINCT
        share_code,
        MAX( highest ) over ( PARTITION BY share_code ) AS maxHighest,
        round( first_value ( end_value / ( 1 + rise_fall_ratio * 0.01 ) ) over ( PARTITION BY share_code ORDER BY date ), 2 ) AS lastEndValue,
        round( first_value ( deal_amount ) over ( PARTITION BY share_code ORDER BY date ), 2 ) AS FIRSTDealAmount,
        round( first_value ( turn_over_rate ) over ( PARTITION BY share_code ORDER BY date ), 2 ) AS FIRSTTurnOverRate,
        date,
        SUM( rise_fall_ratio ) over ( PARTITION BY share_code ORDER BY date ) AS sumRatio,
        MIN( lowest ) over ( PARTITION BY share_code ) AS minLowest
        FROM
        (
        SELECT
        share_code,
        rise_fall_ratio,
        highest,
        lowest,
        open_value,
        end_value,
        deal_amount,
        turn_over_rate,
        date,
        count(share_code) over (PARTITION by share_code) as count
        FROM
        market_info_new
        WHERE
        share_code IN (
        SELECT
        share_code
        FROM
        market_info_new
        WHERE
        share_code IN (

        SELECT
        share_code
        FROM
        market_info_new
        WHERE
        date >=  #{upStartTime}
        AND date  &lt; #{upEndTime}
        AND rise_fall_ratio > 0

        GROUP BY
        share_code
        HAVING
        SUM( rise_fall_ratio ) >= #{minRate}

        AND  COUNT( share_code ) >= #{minUpDay}

        )
        AND date >= #{downStartTime}
        AND date &lt; #{downEndTime}
        AND rise_fall_ratio &lt; 0
        GROUP BY share_code
        HAVING COUNT( share_code ) > #{minDownDay} )
        AND date >= #{selectStartTime}
        <if test="selectEndTime!=null">
        AND date &lt; #{selectEndTime}
        </if>
        and  turn_over_rate>#{minTurnOverRate}
        ORDER BY share_code,date
        ) AS hihi
        where count = #{recentRateDay}
        order by share_code
        ) mm
        WHERE
        FIRSTDealAmount / FIRSTTurnOverRate > 80000000
    </select>
    <select id="queryRecentSerialRedExact" parameterType="com.liuhu.socket.dto.QueryRecentSerialRedConditionDO" resultType="com.liuhu.socket.entity.MarketInfoNew">

        SELECT DISTINCT
        share_code as shareCode,
        date,
        sumCount as   dealAmount,
        secondAmount
        FROM
        (
        select *,
        case when countUp=2 and rise_fall_ratio>0  then sumCount end as secondAmount
        from
        (
        SELECT
        share_code,
        rise_fall_ratio,
        FIRST_value(rise_fall_ratio)over(PARTITION by share_code order by date ) as firstRatio,
        date,
        row_number () over (
        PARTITION BY share_code
        ORDER BY
        date DESC
        ) AS rowhi,
        COUNT(
        CASE
        WHEN rise_fall_ratio > 0 THEN
        1
        END
        ) OVER (
        PARTITION BY share_code
        ORDER BY
        date ROWS BETWEEN 4 PRECEDING
        AND CURRENT ROW
        ) AS countUp,
        sum(rise_fall_ratio) over (
        PARTITION BY share_code
        ORDER BY
        date
        ) AS sumCount,
        turn_over_rate,
        FIRST_value(deal_amount)over(PARTITION by share_code order by date ) as firstDealAmount,
        FIRST_value(turn_over_rate)over(PARTITION by share_code order by date ) as firstTurnOverRate
        FROM
        market_info_new
        WHERE
        date >= #{upStartTime}
        AND date &lt;#{upEndTime}
        ) as nini
        order by share_code,date
        ) AS mimi
        WHERE
        sumCount>0
        and sumCount&lt;20
        and rise_fall_ratio> 0
        and  turn_over_rate> #{minTurnOverRate}
        and firstRatio >0
        and firstDealAmount/firstTurnOverRate >#{minMarketValue}
        and (countUp = #{minUpDay} OR secondAmount>0)
        order by share_code

    </select>

    <select id="queryRecentSerialGreen" parameterType="com.liuhu.socket.dto.QueryRecentSerialRedConditionDO" resultType="com.liuhu.socket.domain.output.QueryRecentSerialRedOutPutDTO">
        SELECT
        share_code as shareCode,
        SUM(rise_fall_ratio) as downSumRatio
        FROM
        market_info_new
        WHERE
        share_code IN
        <foreach collection="condition.marketList" item="it" separator="," open="(" close=")">
            #{it.shareCode}
        </foreach>
        AND date >= #{condition.downStartTime}
        AND date &lt; #{condition.downEndTime}
        GROUP BY share_code
        HAVING COUNT( CASE WHEN rise_fall_ratio &lt; 0  THEN 1 END ) > #{condition.minDownDay}
        and  SUM(rise_fall_ratio)&lt;#{condition.minDownRate}
    </select>
    <select id="queryRecentSerialRedWithHavingShareCode" parameterType="com.liuhu.socket.dto.QueryRecentSerialRedConditionDO" resultType="com.liuhu.socket.domain.output.QueryRecentSerialRedOutPutDTO">
        select
        share_code as shareCode,
        ROUND((maxHighest - lastEndValue)/lastEndValue*100,2) as maxRatio,
        ROUND((minLowest - lastEndValue)/lastEndValue*100,2) as minRatio,
        sumRatio as finalRatio,
        minDate as startTime from
        (
        select share_code,
        MAX(highest) over (PARTITION BY share_code) AS maxHighest,
        round(
        first_value (
        end_value / (1 + rise_fall_ratio * 0.01)
        ) over (
        PARTITION BY share_code
        ORDER BY
        date
        ),
        2
        ) AS lastEndValue,
        MIN(date) over (PARTITION BY share_code) AS minDate,
        date,
        SUM(rise_fall_ratio) over (
        PARTITION BY share_code
        ORDER BY
        date
        ) AS sumRatio,
        MIN(lowest) over (PARTITION BY share_code) AS minLowest,
        row_number()over(PARTITION BY share_code order by date) as rowKey
        from market_info_new
        where
        share_code in
        <foreach collection="condition.shareCodeList" item="it" separator="," open="(" close=")">
            #{it}
        </foreach>
        AND date >= #{condition.selectStartTime}
        <if test="condition.selectEndTime!=null">
            AND date &lt; #{condition.selectEndTime}
        </if>
        ) final
        where rowKey = #{condition.recentRateDay}
    </select>

    <select id="queryPrePurchaseSocker" parameterType="com.liuhu.socket.dto.QueryRecentSerialRedConditionDO" resultType="com.liuhu.socket.domain.output.MarketOutputDomain">
        select
         share_code as shareCode,
         turn_over_rate as turnOverRate,
         rise_fall_ratio as rate
        from market_info_new  kk  where
        kk.share_code in (SELECT
        share_code
        FROM
        market_info_new
        WHERE
        share_code IN (
        SELECT
        share_code
        FROM
        market_info_new
        WHERE
        date >= #{upStartTime}
        AND date &lt;= #{upEndTime}
        AND rise_fall_ratio > 0
        GROUP BY
        share_code
        HAVING
        SUM(rise_fall_ratio) >= #{minRate}
        AND COUNT(share_code) = #{minUpDay}
        )
        AND date >= #{downStartTime}
        AND date &lt; #{downEndTime}
        AND rise_fall_ratio &lt; 0
        GROUP BY
        share_code
        HAVING
        COUNT(share_code) > 7)
        and date =  #{upEndTime}
        and  turn_over_rate >= #{minTurnOverRate}
        and  deal_amount/turn_over_rate > #{minMarketValue}
    </select>
    <select id="queryPreFiveAndSubFiveSocker" resultType="com.liuhu.socket.domain.output.MarketOutputDomain">
        SELECT
        share_code as shareCode,
        date as startTime
        FROM
        (
        SELECT
        *, row_number () over (
        PARTITION BY share_code
        ORDER BY
        date
        ) AS rowhw
        FROM
        (
        SELECT
        share_code,
        rise_fall_ratio,
        COUNT(
        CASE
        WHEN rise_fall_ratio > 0 THEN
        1
        END
        ) OVER (
        PARTITION BY share_code
        ORDER BY
        date ROWS BETWEEN #{periodUpDay} PRECEDING
        AND CURRENT ROW
        ) AS countUp,
        sum(rise_fall_ratio) over (
        PARTITION BY share_code
        ORDER BY
        date
        ) AS sumCount,
        first_value (deal_amount / turn_over_rate) over (
        PARTITION BY share_code
        ORDER BY
        date DESC
        ) AS shizhi,
        first_value (turn_over_rate) over (
        PARTITION BY share_code
        ORDER BY
        date DESC
        ) AS turnOverRate,
        nth_value (rise_fall_ratio, 4) over (
        PARTITION BY share_code
        ORDER BY
        date
        ) AS fourThRatio,
        first_value (rise_fall_ratio) over (
        PARTITION BY share_code
        ORDER BY
        date DESC
        ) AS lastRatio,
        row_number () over (
        PARTITION BY share_code
        ORDER BY
        date
        ) AS rowhi,
        date
        FROM
        market_info_new tt
        WHERE
        tt.date >= #{upStartTime}
        AND tt.date &lt;= #{upEndTime}
        ) fined
        WHERE
        share_code IN (
        SELECT
        share_code
        FROM
        (
        SELECT
        share_code,
        rise_fall_ratio,
        COUNT(
        CASE
        WHEN rise_fall_ratio > 0 THEN
        1
        END
        ) OVER (
        PARTITION BY share_code
        ORDER BY
        date ROWS BETWEEN #{periodDownDay} PRECEDING
        AND CURRENT ROW
        ) AS countUp,
        sum(rise_fall_ratio) over (
        PARTITION BY share_code
        ORDER BY
        date
        ) AS sumCount,
        first_value (deal_amount / turn_over_rate) over (
        PARTITION BY share_code
        ORDER BY
        date
        ) AS shizhi,
        first_value (turn_over_rate) over (
        PARTITION BY share_code
        ORDER BY
        date
        ) AS turnOverRate,
        row_number () over (
        PARTITION BY share_code
        ORDER BY
        date
        ) AS rowhi,
        date
        FROM
        market_info_new tt
        WHERE
        tt.date >= #{downStartTime}
        AND tt.date &lt;= #{downEndTime}
        ) kk
        WHERE
        kk.rowhi = #{periodDownDay}+1
        AND kk.sumCount &lt;- 4
        AND kk.turnOverRate > #{minTurnOverRate}
        AND countUp &lt;= 2
        AND shizhi > #{minMarketValue}
        )
        AND countUp >= #{minUpDay}
        AND turnOverRate > #{minTurnOverRate}
        AND sumCount > 4
        ) ll
        WHERE
        ll.rowhw = 1
        AND (
        CASE
        WHEN ll.rowhi = #{periodUpDay} +1
        AND fourThRatio &lt; 0 THEN
        ABS(lastRatio) > ABS(fourThRatio)
        ELSE
        1 = 1
        END
        )

    </select>

    <select id="queryFiveRatioByCodeAndDate" resultType="com.liuhu.socket.domain.output.MarketOutputDomain">
        SELECT
        share_code as shareCode,
        sumCount as rate
        FROM
        (
        -- 查询满足条件的购买日期开始日期到规定购买的结束日期数据 开始
        SELECT
        mfn.id,
        mfn.share_code,
        rise_fall_ratio,
        mfn.date,
        sn.date as firstDate,
        COUNT(	CASE WHEN rise_fall_ratio > 0 THEN		1	END	) OVER (		PARTITION BY share_code,sn.date		ORDER BY			mfn.date ROWS BETWEEN 2 PRECEDING	AND CURRENT ROW		) AS countUp,
        sum(rise_fall_ratio) over (	PARTITION BY share_code,sn.date	ORDER BY	mfn.date		) AS sumCount,
        row_number () over (	PARTITION BY share_code,sn.date	ORDER BY		sn.date	) AS rowhi
        FROM
        market_info_new mfn,
        (
        -- 根据传入的code 和date  作为一个查询结果集  开始
        SELECT
        share_code,
        date
        FROM
        market_info_new tt
        WHERE
        (share_code, date) IN (

        <foreach collection="list" index="i" item="item" separator=",">
            (
            #{item.shareCode},
            #{item.startTime}
            )
        </foreach>

        )
        -- 根据传入的code 和date  作为一个查询结果集  结束
        ) sn
        WHERE
        mfn.share_code = sn.share_code
        AND mfn.date >= sn.date
        AND mfn.date &lt;= (
        SELECT
        date
        FROM
        trade_date
        WHERE
        id = (SELECT id	FROM	trade_date			WHERE		date = sn.date ) + 5- 1
        )
        -- 查询满足条件的购买日期开始日期到规定购买的结束日期数据 结束
        ) kk
        WHERE
        -- 条件  取连红三天的记录 或者 或者是没有三连红到最后购买截止期限的
        kk.rowhi = 5
    </select>
</mapper>